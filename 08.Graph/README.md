# 그래프 (Graph)
그래프는 정점(vertex)과 간선(edge)으로 구성된 한정된 자료구조를 의미한다. 컴퓨터 시스템에 그래프를 저장하는 방법은 여러가지가 있는데, 실제 적용에 있어서 최적의 자료구조는 리스트와 행렬로 구별된다. 리스트는 적은 메모리 공간을 요구한다. 행렬은 많은 양의 메모리를 필요로 하지만 더욱 빠른 접근이 가능하다.

__정점의 개수가 V개 간선의 개수가 E개인 그래프에 대해__
- 간선리스트 : E*2 or E*3 이차원 배열에 간선 정보 저장
- 인접행렬 : V*V 이차원 배열에 그래프 정보를 저장
- 인접리스트 : V개의 연결리스트에 그래프 정보를 저장
### 그래프 용어
- 무향간선, 유향간선, 다중간선
- 인접, 부속 : 간선e는 정점 v1, v2에 부속한다., 차수 : 정점에 부속된 간선의 수
- Cycle : 시작정점과 끝 정점이 같은 경로
- 무향그래프, 유향그래프, 가중치그래프, 정규그래프, 완전그래프, 연결그래프, 부분그래프, 트리그래프

## 쾨니히스베르크 다리 건너기 문제 
<image src="./images/오일러 스케치.png">

> 쾨니히스베르크시의 한 가운데는 프레겔 강이 흐르고 있고 여기에는 가운데 섬들과 연결되어있는 일곱 개의 다리가 있다. 그 다리들을 한 번씩만 차례로 모두 건널 수 있겠는가?

## 외판원 문제(The Travleing sales-woman problem) - DP
<image src="./images/외판원문제.png">
: 외판원이 거주하고 있는 도시에서 출발하여 n개의 각 도시를 한 번씩 방문하고, 다시 출발한 도시로 돌아오는 가장 짧은 여행길을 찾고 싶다. 이런 최단 여행 경로를 구하는 문제를 외판원 문제라고 한다.

만약 도시가 20개라고 할 때, 이 문제의 정답을 찾기 위해 다녀야 하는 총 경로의 수는 20!다. `2,432,902,0008,176,640,000`이다.

1. 동적계획으로 풀기
- W : 주어진 그래프의 인접행렬
- V : 모든 도시의 집합
- A : V의 부분집합
- D[vi][A]: A에 속한 도시를 각각 한 번씩만 거쳐서 vi에서 v1으로 가는 최단 경로의 길이

__재귀 관계식__
```
D[vi][A] = minimum(W[i][j]+ D[vj][A-vj])
D[vi][{}] = W[i][1]
```

- 부분집합 표현 : 비트를 이용한 부분집합의 표현과 연산
V - {v1} = {v2, v3, v4}
0 ~ 7 까지 표현 가능
0 - {}
1 - {v2}
2 - {v3}
4 - {v4}
3 - {v2, v3}
5 - {v2, v4}
6 - {v3, v4}
7 - {v2, v3, v4}





2. 분기 한정으로 풀기


### 플로이드 알고리즘 (Floyd) - DP
: 모든 정점 쌍에 대해서 둘 사이의 최단 거리를 구할 수 있다.
### 플로이드 알고리즘 단계
1. 그래프의 초기화
 - 초기에 직접적으로 연결되어 있지 않은 경로는 INF로 설정하고, 자기 자신까지의 비용은 0 으로 만들어준다. 
2. 플로이드 알고리즘 적용
- 시작점을 i, 끝점을 j, 경유점을 k 라고 할때 다음 식 `adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j])`를 반복한다.
3. 연결되지 않는 선이 INF로 되어 있기 때문에 min의 값에서 제외가 되고 모든 정점쌍 사이에 최단 거리를 구할 수 있다.

<image src="./images/Floyd.png"/>
### 플로이드 알고리즘 코드
```
# input
# 5 6
# 0 1 2
# 0 2 3
# 1 4 10
# 2 4 4
# 2 3 1
# 3 4 2

import sys
import pprint as pp

V, E = map(int, sys.stdin.readline().split(" "))
W = [[0] * V for _ in range(V)]
D = []
for _ in range(E):
    v1, v2, cost = map(int, sys.stdin.readline().split(" "))
    W[v1][v2] = cost
    W[v2][v1] = cost

for i in range(V):
    tmp = []
    for j in range(V):
        if i == j:
            tmp.append(0)
        elif W[i][j] != 0:
            tmp.append(W[i][j])
        else:
            tmp.append(float('inf'))
    D.append(tmp)

# pp.pprint(W)
pp.pprint(D)

for i in range(V):
    for j in range(V):
        for k in range(V):
            D[i][j] = min(D[i][j], D[i][k]+D[k][j])

pp.pprint(D)

```

- 시간복잡도 : `O(n^3)`
- 공간복잡도 : `O(n^2)`


